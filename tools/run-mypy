#!/usr/bin/env python3
import os
import sys
import argparse
import subprocess
import lister
from typing import cast, Dict, List
from pathlib import PurePath

EXCLUDE_FILES = ['tools/fetch-pull-request', 'tools/fetch-rebase-pull-request']

TOOLS_DIR = os.path.dirname(os.path.abspath(__file__))
os.chdir(os.path.dirname(TOOLS_DIR))

sys.path.append(os.path.dirname(TOOLS_DIR))
from lib.test_script import assert_provisioning_status_ok

exclude = """
stubs/
""".split()

parser = argparse.ArgumentParser(description="Run mypy on files tracked by git.")
parser.add_argument('targets', nargs='*',
                    help="files and directories to check (default: .)")
parser.add_argument('--version', action='store_true',
                    help="show mypy version information and exit")
parser.add_argument('-m', '--modified', action='store_true',
                    help="check only modified files")
parser.add_argument('--scripts-only', action='store_true',
                    help="only check extensionless python scripts")
parser.add_argument('-a', '--all', action='store_true',
                    help="check all files, bypassing the default exclude list")
parser.add_argument('--force', action="store_true",
                    help="run tests despite possible provisioning problems")
parser.add_argument("--quiet", action="store_true",
                    help="suppress mypy summary output")
args = parser.parse_args()

assert_provisioning_status_ok(args.force)

command_name = "mypy"

# Use zulip-py3-venv's mypy if it's available.
VENV_DIR = "/srv/zulip-py3-venv"
MYPY_VENV_PATH = os.path.join(VENV_DIR, "bin", command_name)
if os.path.exists(MYPY_VENV_PATH):
    mypy_command = MYPY_VENV_PATH
else:
    mypy_command = command_name

if args.version:
    print("mypy command:", mypy_command)
    sys.exit(subprocess.call([mypy_command, "--version"]))

if args.all:
    exclude = []

# find all non-excluded files in current directory
files_dict = lister.list_files(
    targets=args.targets, ftypes=['py', 'pyi'],
    use_shebang=True, modified_only=args.modified,
    exclude=exclude, group_by_ftype=True,
    extless_only=args.scripts_only,
)
pyi_files = list(files_dict['pyi'])
python_files = [fpath for fpath in files_dict['py']
                if not fpath.endswith('.py') or fpath + 'i' not in pyi_files]
if not python_files and not pyi_files:
    print("There are no files to run mypy on.")
    sys.exit(0)

mypy_args: List[str] = []
if args.quiet:
    mypy_args += ["--no-error-summary"]
mypy_args += ["--"] + python_files + pyi_files
rc = subprocess.call([mypy_command] + mypy_args)

if rc != 0:
    print("")
    print("See https://zulip.readthedocs.io/en/latest/testing/mypy.html for debugging tips.")

sys.exit(rc)

parser = argparse.ArgumentParser(description="Run mypy on files tracked"
                                             " by git.")

parser.add_argument('targets', nargs='*', default=[],
                    help="""files and directories to include in the result.
                    If this is not specified, the current directory is used""")

parser.add_argument('-m', '--modified', action='store_true', default=False,
                    help='list only modified files')

parser.add_argument('-a', '--all', dest='all', action='store_true',
                    default=False, help="""run mypy on all python files,
                    ignoring the exclude list. This is useful if you have to 
                    find out which files fail mypy check.""")

parser.add_argument('--no-disallow-untyped-defs', dest='disallow_untyped_defs',
                    action='store_false', default=True,
                    help="""Don't throw errors when functions are not
                    annotated""")

parser.add_argument('--scripts-only', dest='scripts_only',
                    action='store_true', default=False,
                    help="""Only type check extensionless python scripts""")

parser.add_argument('--no-strict-optional', dest='strict_optional',
                    action='store_false', default=True,
                    help="""Don't use the --strict-optional flag with mypy""")

parser.add_argument('--warn-unused-ignores', dest='warn_unused_ignores',
                    action='store_true', default=False,
                    help="""Use the --warn-unused-ignores flag with mypy""")

parser.add_argument('--no-ignore-missing-imports',
                    dest='ignore_missing_imports', action='store_false',
                    default=True, help="""Don't use the
                     --ignore-missing-imports flag with mypy""")

parser.add_argument('--quick', action='store_true', default=False,
                    help="""Use the --quick flag with mypy""")

args = parser.parse_args()

files_dict = cast(Dict[str, List[str]],
                  lister.list_files(targets=args.targets, ftypes=['py'],
                                    use_shebang=True,
                                    modified_only=args.modified,
                                    group_by_ftype=True,
                                    exclude=EXCLUDE_FILES,
                                    ))


pyi_files = set(files_dict['pyi'])
python_files = [fpath for fpath in files_dict['py']
                if not fpath.endswith('.py') or fpath + 'i' not in pyi_files]

repo_python_files = {}
repo_python_files['zulipterminal'] = []
for file_path in python_files:
    repo = PurePath(file_path).parts[0]
    if repo in repo_python_files:
        repo_python_files[repo].append(file_path)

mypy_command = "mypy"

extra_args = ["--check-untyped-defs",
              "--follow-imports=silent",
              "--scripts-are-modules",
              "--disallow-any-generics",
              "-i"]
if args.disallow_untyped_defs:
    extra_args.append("--disallow-untyped-defs")
if args.warn_unused_ignores:
    extra_args.append("--warn-unused-ignores")
if args.strict_optional:
    extra_args.append("--strict-optional")
if args.ignore_missing_imports:
    extra_args.append("--ignore-missing-imports")
if args.quick:
    extra_args.append("--quick")

# run mypy
status = 0
for repo, python_files in repo_python_files.items():
    print("Running mypy for `{}`.".format(repo), flush=True)
    if python_files:
        result = subprocess.call([mypy_command] + extra_args + python_files)
        if result != 0:
            status = result
    else:
        print("There are no files to run mypy on.")
sys.exit(status)
